%%{ 

%} 

%option noyywrap 

/*Para ignorar tabulaÃ§Ã£o, quebra de linha e espaÃ§o em branco*/
delim		 [ \t\n\r] 
ws		   {delim}+ 

/* identificaÃ§Ã£o */ 
digito [0-9]
caractere [a-zA-Z]
digitoPositivo \+?{digito}+
digitoNegativo \-{digito}+
decimal ({digneg}|{digpos})\.{digpos}
palavra [{caractere}]+

true Acesa
false Apagada
void vazio
break end
continue pular

variavel {caractere}({caractere}|{digito})*

/* AritmÃ©ticos e lÃ³gicos */

soma âš’ï¸|+
subtracao âš”ï¸|-
multiplicacao ğŸ’£|*
divisao ğŸª£|/
mod ğŸªµ| %
incremento minerar({variavel})
decremento colocar_bloco({variavel})
maisIgual regenerar({variavel}, {digito}) 
menosIgual veneno({variavel}, {digito})
multiplicadorIgual creeper({variavel}, {digito})
igual ğŸ§±ğŸ§± | ==
diferente ğŸ§±â¬œ | !=
menor ğŸ”½ğŸªœ | <
maior ğŸ”¼ğŸªœ | >
menorIgual ğŸ§±ğŸ”½ | <=
maiorIgual ğŸ§±ğŸ”¼ | >=


/* Tipos Primitivos */
inteiro hp
float xp
bool tocha
string livro
char fragmento
double bussola
void vazia 
/* ver se deixa aqui ou lÃ¡ */ 


/* Palavras reservadas */
escopo inventario
null nether
if observador
else liberador
while comparador 
do redstone
for repetidor
switch carrinho
case trilho
defalt cacto 
break end // ver tbm
continue pular // ver tbm 
return overwold
import portal 
typecast villager



%% 

{ws}		{/*nenhuma acao e nenhum retorno*/} 
{digitoPositivo}    { printf("Foi encontrado um numero inteiro positivo. LEXEMA: %s\n", yytext); }
{digitoNegativo}    { printf("Foi encontrado um numero inteiro negativo. LEXEMA: %s\n", yytext); }
{decimal}   { printf("Foi encontrado um numero com parte decimal. LEXEMA: %s\n", yytext); }


%% 

/*codigo em C. Foi criado o main, mas podem ser criadas outras funcoes aqui.*/ 

int main(void) 
{ 
    /* Call the lexer, then quit. */ 
    yylex(); 
    return 0; 
}